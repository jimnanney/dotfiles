" Most of this is taken from Gary Bernhardt's .vimrc
" available from here: https://github.com/garybernhardt/dotfiles/blob/master/.vimrc
set nocompatible
filetype off

let g:ale_completion_enabled = 1
let g:ale_sign_column_always = 1
runtime macros/matchit.vim
set rtp+=~/.vim/bundle/Vundle.vim
"set rtp+=/usr/local/lib/python3.7/site-packages/powerline/bindings/vim
call vundle#begin()
Plugin 'airblade/vim-gitgutter'
Plugin 'jpo/vim-railscasts-theme'
Plugin 'vim-airline/vim-airline'
Plugin 'VundleVim/Vundle.vim'
Plugin 'ctrlpvim/ctrlp.vim'
Plugin 'editorconfig/editorconfig'
Plugin 'mattn/emmet-vim'
Plugin 'othree/html5.vim'
Plugin 'Quramy/tsuquyomi'
Plugin 'leafgarland/typescript-vim'
Plugin 'altercation/vim-colors-solarized'
Plugin 'jason0x43/vim-js-indent'
Plugin 'junegunn/fzf'
Plugin 'junegunn/fzf.vim'
Plugin 'tpope/vim-bundler'
Plugin 'tpope/vim-endwise'
Plugin 'tpope/vim-fugitive'
Plugin 'tpope/vim-projectionist'
Plugin 'tpope/vim-rails'
Plugin 'tpope/vim-repeat'
Plugin 'tpope/vim-surround'
Plugin 'tpope/vim-unimpaired'
Plugin 'tpope/vim-abolish'
Plugin 'tpope/vim-dispatch'
Plugin 'vim-ruby/vim-ruby'
Plugin 'flazz/vim-colorschemes'
"Plugin 'danchoi/ri.vim'

"Plugin 'dense-analysis/ale'
call vundle#end()
filetype plugin indent on
"set path+=**
set wildignore+=node_modules/**,log/**,coverage/**
let g:typescript_indent_disable = 1
" Section: Spelling {{{
" ---------------------
abbr thier their
abbr recieve receive

" Section: Options {{{1
" ---------------------
syntax enable
filetype plugin indent on
set tags+=.git/tags
set tags+=.gemtags
set clipboard=unnamed
set updatetime=100
set number
set nocompatible
" allow unsaved background buffers and remember marks/undo for them
set hidden
" remember more commands and search history
set history=10000
set expandtab
set tabstop=2
set shiftwidth=2
set softtabstop=2
set autoindent
set laststatus=2
set showmatch
set incsearch
set hlsearch
" make searches case-sensitive only if they contain upper-case characters
set ignorecase smartcase
" highlight current line
set cursorline
set cmdheight=2
set switchbuf=useopen
set numberwidth=5
set showtabline=2
set winwidth=79
" Prevent Vim from clobbering the scrollback buffer. See
" http://www.shallowsky.com/linux/noaltscreen.html
set t_ti= t_te=
" keep more context when scrolling off the end of a buffer
set scrolloff=3
" Store temporary files in a central spot
set backup
set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
" allow backspacing over everything in insert mode
set backspace=indent,eol,start
" display incomplete commands
set showcmd
" use emacs-style tab completion when selecting files, etc
set wildmode=longest,list
" make tab completion for files/buffers act like bash
set wildmenu
"let mapleader=","
set undodir=$HOME/.vim/undo
set undolevels=1000
set undoreload=10000
set nojoinspaces
" this fixes the O insert taking so long
set timeout timeoutlen=1000 ttimeoutlen=100
set modeline
set modelines=3
set wildignore+=tmp/*,*.swp,*.zip,*.exe,*.class,*.jar,*.ear,*.war
let g:ctrlp_working_path_mode='ra'
let g:ctrlp_custom_ignore = {
      \ 'dir': '\.git$\|\.hg$\|\.svn$\|classes$\|node_modules$\|tmp$\|packs$\|packs-test$\|dist$\|coverage$',
      \ 'file': '\.exe$\|\.so$\|\.dll$\|\.class$\|\.jar$\|\.ear$\|.\war$',
      \ 'link': 'SOME_BAD_SYMBOLIC_LINKS',
      \ }
let g:ctrlp_max_files = 100000
let g:ctrlp_max_depth = 100
"let g:ctrlp_user_command = ['.git/', 'git --git-dir=%s/.git ls-files -oc --exclude-standard']
nnoremap <leader>; :CtrlPTag<cr>
set splitbelow
set splitright
set grepprg=git\ grep\ -nI
" scanning included files can be slow
set complete-=i

" Section: Folding {{{1
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" FOLDING
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

set foldtext=MyFoldText()

set fillchars="fold: ,diff:-"

function! MyFoldText()
  let length = v:foldend - v:foldstart
  let line = getline(v:foldstart)
  let sub = substitute(line, '/\*\|\*/\|{{{\d\=', '', 'g')
  let foldtext = substitute(sub, '^\s\+\|\s\+$', '', 'g')
  return v:folddashes . "+ ". foldtext . " (" . length . " lines) +" . v:folddashes
endfunction

"v:foldstart  line number of first line in the fold
"v:foldend    line number of last line in the fold
"v:folddashes a string that contains dashes to represent the
"             foldlevel.
"v:foldlevel  the foldlevel of the fold


" Section: Autocmds {{{1
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CUSTOM AUTOCMDS
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
augroup vimrcEx
  " Clear all autocmds in the group
  autocmd!
  autocmd FileType text setlocal textwidth=78
  autocmd FileType vim set foldmethod=marker foldenable

  "autocmd BufNewFile,BufRead *.hbs set ft=handlebars

  " have to work with VB .net so add these here
  autocmd BufNewFile,BufRead *.vb set ft=vbnet
  au BufNewFile,BufReadPost *.coffee setl shiftwidth=2 expandtab sts=2

  " Jump to last cursor position unless it's invalid or in an event handler
  autocmd BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal g`\"" |
    \ endif

  autocmd BufRead,BufNewFile *.ts setlocal filetype=typescript
  autocmd BufRead,BufNewFile *.tsx setlocal filetype=typescript
  "autocmd FileType ruby,erbuy,haml,yaml,html,sass,scss,cucumber,javascript,javascript.tsx,typescript setlocal foldmethod=syntax foldenable
  "autocmd FileType ruby,erbuy,haml,yaml,html,sass,scss,cucumber,javascript,javascript.tsx,typescript normal zR
  "for ruby, autoindent with two spaces, always expand tabs
  autocmd FileType ruby,haml,eruby,yaml,html,sass,cucumber,html.handlebars,html.moustache set ai sw=2 sts=2 et tw=130 cc=+1
  autocmd FileType javascript,javascript.jsx set ai sw=2 sts=2 nobomb
  autocmd FileType typescript setlocal ai ci si
  autocmd FileType typescript set sw=2 sts=2 nobomb
  autocmd FileType typescript,javascript,javascript.jsx nnoremap <buffer> <Leader>. :call OpenTestAlternateTS()<cr>
  autocmd FileType typescript,javascript,javascript.jsx nnoremap <buffer> <Leader>t :call RunMochaTest()<cr>
  autocmd FileType typescript,javascript,javascript.jsx nnoremap <buffer> <Leader>tu :call RunJestUpdate()<cr>
  autocmd FileType typescript,javascript,javascript.jsx nnoremap <buffer> <Leader>T :call RunSingleMochaTest()<cr>
  autocmd FileType typescript nnoremap <buffer> <Leader>i :TsuImport<cr>
  autocmd FileType typescript nnoremap <buffer> <Leader>h : <C-u>echo tsuquyomi#hint()<CR>

  autocmd! BufRead,BufNewFile *.sass setfiletype sass
  autocmd BufRead,BufNewFile {Guardfile,Gemfile,Rakefile} set filetype=ruby

  autocmd BufRead *.md  set ai formatoptions=tcroqn2 comments=n:&gt;
  autocmd BufRead *.mkd  set ai formatoptions=tcroqn2 comments=n:&gt;
  autocmd BufRead *.markdown  set ai formatoptions=tcroqn2 comments=n:&gt;

  " Indent p tags
  " autocmd FileType html,eruby if g:html_indent_tags !~ '\\|p\>' | let g:html_indent_tags .= '\|p\|li\|dt\|dd' | endif

  " Don't syntax highlight markdown because it's often wrong
  autocmd! FileType mkd setlocal syn=off

  " Leave the return key alone when in command line windows, since it's used
  " to run commands there.
  autocmd! CmdwinEnter * :unmap <cr>
  autocmd! CmdwinLeave * :call MapCR()
  autocmd BufWritePost $MYVIMRC source $MYVIMRC
augroup END

" Set space quote to wrap a word in quotes
nnoremap <space>" ciw"<c-r>""<esc>
nnoremap <space>' ciw'<c-r>"'<esc>

" Section: Colors {{{1
" --------------------

set t_Co=256 " 256 colors
set background=light
let g:solarized_termcolors = 256
let g:solarized_termtrans = 0
let g:solarized_degrade = 1
let g:solarized_bold = 1
let g:solarized_underline = 1
let g:solarized_italic = 0
let g:solarized_contrast = "high"
let g:solarized_visibility= "high"

"colorscheme solarized
"colorscheme rubyblue
"colorscheme solarized
"colorscheme detailed
"colorscheme monokai
colorscheme railscasts
"set listchars=tab:>\ ,extends:>,precedes:<,nbsp:+,trail:â›µ
if (&termencoding ==# 'utf-8' || &encoding ==# 'utf-8') && v:version >= 700
  let &g:listchars = "tab:\u21e5\u00b7,trail:\u2423,extends:\u21c9,precedes:\u21c7,nbsp:\u00b7"
  let &g:fillchars = "vert:\u250b,fold:\u00b7"
else
  setglobal listchars=tab:>\ ,trail:-,extends:>,precedes:<
endif
"set listchars=tab:>\ ,trail:-,extends:>,precedes:<,nbsp:+
set list

highlight GitGutterAdd    guifg=#009900 ctermfg=2
highlight GitGutterChange guifg=#bbbb00 ctermfg=3
highlight GitGutterDelete guifg=#ff2222 ctermfg=1
" hi Comment ctermfg=67 ctermbg=23
"hi VimLineComment ctermfg=66 ctermbg=23

" Section: Status Line  {{{1
" --------------------------
:set statusline=%<%f\ (%{&ft})\ %-4(%m%)%=%-19(%3l,%02c%03V%)

" Section: Misc Key Maps {{{1
" ---------------------------
noremap [e :ALEPreviousWrap<cr>
noremap ]e :ALENextWrap<cr>
nnoremap <leader>d :ALEGoToDefinition -vsplit<cr>
"nnoremap <leader>f :ALEFix<cr>
"nnoremap <leader>rf :ALEFindReferences -vsplit<cr>
"inoremap <C-Space> <C-\><C-O>:ALEComplete<cr>
noremap <leader>y "*y
noremap <leader>] :!ruby ~/bin/test_runner.rb<cr>

" Move around splits with <c-hjkl>
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l
" Insert a hash rocket with <c-l>
inoremap <c-l> <space>=><space>
" Can't be bothered to understand ESC vs <c-c> in insert mode
inoremap <c-c> <esc>
" Clear the search buffer when hitting return
function! MapCR()
  nnoremap <cr> :nohlsearch<cr>
endfunction
call MapCR()
nnoremap <leader><leader> <c-^>

" Section: Tab Key Handling {{{1
" ------------------------------
"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MULTIPURPOSE TAB KEY
" Indent if we're at the beginning of a line. Else, do completion.
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! InsertTabWrapper()
    let col = col('.') - 1
    if !col || getline('.')[col - 1] !~ '\k'
        return "\<tab>"
    else
        return "\<c-p>"
    endif
endfunction
inoremap <tab> <c-r>=InsertTabWrapper()<cr>
inoremap <s-tab> <c-n>

" Section: Arrow Keys {{{1
" ------------------------
" Make as no operation - retrain fingers to use hjkl
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" ARROW KEYS ARE UNACCEPTABLE
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
noremap <Left> <Nop>
noremap <Right> <Nop>
noremap <Up> <Nop>
noremap <Down> <Nop>


" Section: Opening Files {{{1
" ------------------------
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" OPEN FILES IN DIRECTORY OF CURRENT FILE
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
cnoremap %% <C-R>=expand('%:h').'/'<cr>
noremap <leader>e :edit %%
noremap <leader>v :view %%


" Section: FileJumps {{{1
noremap <leader>gr :topleft :split config/routes.rb<cr>
function! ShowRoutes()
  " Requires 'scratch' plugin
  :topleft 100 :split __Routes__
  " Make sure Vim doesn't write __Routes__ as a file
  :set buftype=nofile
  " Delete everything
  :normal 1GdG
  " Put routes output in buffer
  :0r! rake -s routes
  " Size window to number of lines (1 plus rake output length)
  :exec ":normal " . line("$") . "_ "
  " Move cursor to bottom
  :normal 1GG
  " Delete empty trailing line
  :normal dd
endfunction
noremap <leader>gR :call ShowRoutes()<cr>
noremap <leader>gv :CtrlP app/views<cr>
noremap <leader>gc :CtrlP app/controllers<cr>
noremap <leader>gm :CtrlP app/models<cr>
noremap <leader>gh :CtrlP app/helpers<cr>
noremap <leader>gl :CtrlP lib<cr>
noremap <leader>gp :CtrlP public<cr>
noremap <leader>gs :CtrlP app/services<cr>
noremap <leader>gf :CtrlP spec/factories<cr>
noremap <leader>gg :topleft 100 :split Gemfile<cr>
noremap <leader>gt :CommandTFlush<cr>\|:CommandTTag<cr>
nnoremap <leader>ff :Files<cr>
nnoremap <leader>F :Files<space>

" Section: Switch between test and production code {{{1
" ------------------------
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" SWITCH BETWEEN TEST AND PRODUCTION CODE
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! OpenTestAlternateTS()
  let new_file = AlternateForCurrentTSFile()
  exec ':e ' . new_file
endfunction

function! OpenTestAlternate()
  let new_file = AlternateForCurrentFile()
  exec ':e ' . new_file
endfunction

function! AlternateForCurrentTSFile()
  let current_file = expand("%")
  let new_file = current_file
  let in_spec = match(current_file, '^app/javascript/test/') != -1
  let going_to_spec = !in_spec
  if going_to_spec
    let new_file = substitute(new_file, '^app/javascript/src/\(.*\).\([jt]s[x]\?\)$', 'app/javascript/test/\1Test.\2', '')
  else
    let new_file = substitute(new_file, '^app/javascript/test/\(.*\)Test.\([jt]s[x]\?\)', 'app/javascript/src/\1.\2', '')
  endif
  return new_file
endfunction

function! AlternateForCurrentFile()
  let current_file = expand("%")
  let new_file = current_file
  let in_spec = match(current_file, '^spec/') != -1
  let going_to_spec = !in_spec
  let in_app = match(current_file, '\<controllers\>') != -1 || match(current_file, '\<models\>') != -1 || match(current_file, '\<views\>') || match(current_file, '\<helpers\>') != -1 || match(current_file, '\<services\>') != -1

  if going_to_spec
    if in_app
      let new_file = substitute(new_file, '^app/', '', '')
    end
    let new_file = substitute(new_file, '\.rb$', '_spec.rb', '')
    let new_file = 'spec/' . new_file
  else
    let new_file = substitute(new_file, '_spec\.rb$', '.rb', '')
    let new_file = substitute(new_file, '^spec/', '', '')
    if in_app
      let new_file = 'app/' . new_file
    end
  endif
  return new_file
endfunction
nnoremap <leader>. :call OpenTestAlternate()<cr>

" Section: Running Tests {{{1
" ------------------------
noremap <leader>t :call RunTestFile()<cr>
noremap <leader>T :call RunNearestTest()<cr>
noremap <leader>a :call RunTests('')<cr>
noremap <leader>c :w\|:!script/features<cr>
noremap <leader>w :w\|:!script/features --profile wip<cr>
noremap <leader>u :!ruby %
noremap <leader>c :!rubocop %<cr>

function! RunTestFile(...)
    if a:0
        let command_suffix = a:1
    else
        let command_suffix = ""
    endif

    " Run the tests for the previously-marked file.
    let in_test_file = match(expand("%"), '\(.feature\|_spec.rb\)$') != -1
    if in_test_file
        call SetTestFile()
    elseif !exists("t:grb_test_file")
        return
    end
    call RunTests(t:grb_test_file . command_suffix)
endfunction

function! RunNearestTest()
    let spec_line_number = line('.')
    call RunTestFile(":" . spec_line_number)
endfunction

function! SetTestFile()
    " Set the spec file that tests will be run for.
    let t:grb_test_file=@%
endfunction

function! RunTests(filename)
    " Write the file and run tests for the given filename
    if match(a:filename, '\feature_spec.rb$') != -1
      let skip_pack = ""
    else
      let skip_pack = "SKIP_WEBPACKER=true "
    end
    :w
    :silent !echo;echo;echo;echo;echo;echo;echo;echo;echo;echo
    :silent !echo;echo;echo;echo;echo;echo;echo;echo;echo;echo
    :silent !echo;echo;echo;echo;echo;echo;echo;echo;echo;echo
    :silent !echo;echo;echo;echo;echo;echo;echo;echo;echo;echo
    :silent !echo;echo;echo;echo;echo;echo;echo;echo;echo;echo
    :silent !echo;echo;echo;echo;echo;echo;echo;echo;echo;echo
    if match(a:filename, '\.feature$') != -1
        exec ":!script/features " . a:filename
    else
        if filereadable("script/test")
            exec ":!script/test " . a:filename
        elseif filereadable("Gemfile")
            exec ":!" . skip_pack . "RAILS_ENABLE_TEST_LOG=true SHOW_CHROME=true bundle exec rspec --color " . a:filename
        else
            exec ":!" . skip_pack . "rspec --color " . a:filename
        end
    end
endfunction

function! RunMochaTest()
  let current_file = expand('%')
  let not_in_spec = match(current_file, '^app/javascript/test/') == -1
  if not_in_spec
    let current_file = './' . shellescape(AlternateForCurrentTSFile())
  endif
  "export NODE_ENV=test; export TZ=America/New_York; mocha --opts ./app/javascript/test/mocha.opts './app/javascript/test/**/*.@(js|jsx|ts|tsx)'",
  exec ':!yarn run test ' . current_file
endfunction

function! RunJestUpdate()
  let current_file = expand('%')
  let not_in_spec = match(current_file, '^app/javascript/test/') == -1
  if not_in_spec
    let current_file = './' . shellescape(AlternateForCurrentTSFile())
  endif
  "export NODE_ENV=test; export TZ=America/New_York; mocha --opts ./app/javascript/test/mocha.opts './app/javascript/test/**/*.@(js|jsx|ts|tsx)'",
  exec ':!yarn run test -u ' . current_file
endfunction

function! RunSingleMochaTest()
  let current_file = expand('%')
  let not_in_spec = match(current_file, '^app/javascript/test/') == -1
  if not_in_spec
    if exists("s:lastsingletestrun")
      exec s:lastsingletestrun
    endif
    return
  endif
  let position = line('.')
  let lastjumppos = line('.')
  let desc = ""
  while 1
    keepjumps normal! [{
    if line('.') == lastjumppos
      break
    endif
    let lastjumppos = line('.')
    let matches = matchlist(getline('.'),'\(describe\|it\|context\)\s*(\s*[''"]\(.*\)[''"]\s*,')
    if len(matches) > 0
      if len(matches[2]) > 0
        if len(desc) > 0
          let desc = ' ' . desc
        endif
        let desc = matches[2] . desc
      endif
    endif
  endwhile
  exec 'keepjumps normal! ' . position . 'G'
  let current_file = "./" . shellescape(current_file)
  let args = ' -g "' . shellescape(desc, 1) . '"'
  "export NODE_ENV=test; export TZ=America/New_York; mocha --opts ./app/javascript/test/mocha.opts './app/javascript/test/**/*.@(js|jsx|ts|tsx)'",
  let s:lastsingletestrun = ':!yarn run test ' . current_file . ' -t ' . shellescape(desc, 1)
  exec s:lastsingletestrun
endfunction

" Section: MD5 {{{1
" ------------------------
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Md5 COMMAND
" Show the MD5 of the current buffer
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
command! -range Md5 :echo system('echo '.shellescape(join(getline(<line1>, <line2>), '\n')) . '| md5')

" Section: CurlyToBlock {{{1
" --------------------------
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CurlyToBlock
" Change a curly brace one line block to a do end multi-line block
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
nnoremap <leader>A vi["ayf=lv$h"byddOallow(ENV).to receive(:[]).with(<esc>"apA).and_return(<esc>"bpA)<esc>
nnoremap <leader>B  ^vi{"ay^elC do<esc>"ap==<esc>$xo end<esc>==
" 
" Function: RenameFile - Rename Current File {{{1
" ------------------------
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" RENAME CURRENT FILE
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! RenameFile()
    let old_name = expand('%')
    let new_name = input('New file name: ', expand('%'), 'file')
    if new_name != '' && new_name != old_name
        exec ':saveas ' . new_name
        exec ':silent !rm ' . old_name
        redraw!
    endif
endfunction
noremap <leader>n :call RenameFile()<cr>

function! FindBlock()
  let current = getline('.')
  let paren = match(current, '\v\([^)]*$')
  let bracket = match(current, '\v\[[^\]]*$')
  let brace = match(current, '\v\{[^}]*$')
  let matches = [paren, bracket, brace]
  "let doblock = -1 "match(current, '\vdo ([^(end)]*$')
  call filter(matches, 'v:val > -1')
  let position = line('.')
  if empty(matches)
    return -1
  endif
  let column = min(matches)
  call cursor(position, column)
  exec 'keepjumps normal! %'
  let end_position = line('.')
  call cursor(position, 0)
  return end_position
endfunction

noremap <leader>pl :call FindBlock()<cr>

function! IsStartOrEnd()
  let found = match(getline('.'), '\%' . col('.') . 'c\(\[\|\]\|(\|)\|{\|}\)')
  return found
endfunction

function! SplitInsideParens()
  let found = IsStartOrEnd()
  if found == -1
    return
  endif
  "exec "normal! 0f(a\<cr>\<esc>vi(:s/, /,\<C-v>\<C-m>/g\<cr>vi(=])i\<cr>\<esc>"
  exec "normal! a\<cr>\<esc>k$v%:s/, /,\<C-v>\<C-m>/g\<cr>%v%=%Xi\<cr>\<esc>%v%="
  "vi(=])i\<cr>\<esc>"
endfunction

function! JoinInsideParens()
  let found = IsStartOrEnd()
  if found == -1
    return
  endif
  "exec "normal! va(JF(lx\<cr>"
  normal! %v%J%
endfunction

noremap <leader>M :call JoinInsideParens()<cr>
"map <leader>m :call IsStartOrEnd()<cr>
noremap <leader>m :call SplitInsideParens()<cr>

" Function: PromoteToLet - Promote Variable to RSpec let {{{1
" ------------------------
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" PROMOTE VARIABLE TO RSPEC LET
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! PromoteToLet()
  let position = line('.')
  let results = FindBlock()
  if results == -1
    :keepjumps normal! dd
    :call search('describe\|context', 'b')
    :keepjumps normal! p
    :.s/\(\w\+\) = \(.*\)$/let(:\1) { \2 }/
    :keepjumps normal ==
    exec 'keepjumps normal! ' . position . 'G'
  else
    let @a = 'let(:'
    keepjumps normal! 0wvaw"Axdw
    let @a .= ") do\n"
    exec 'keepjumps normal! V' . results . 'G"Ax'
    let @a .= "end\n"
    call search('describe\|context', 'b')
    exec 'keepjumps normal! "agp'
    :keepjumps normal! k%V%=
  endif
endfunction
:command! PromoteToLet :call PromoteToLet()
:noremap <leader>p :PromoteToLet<cr>
":noremap <leader>p :!ruby -rminitest/pride *_test.rb<cr>

" Function: ExtractVariable {{{1
" ------------------------
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" EXTRACT VARIABLE (SKETCHY)
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! ExtractVariable()
    let name = input("Variable name: ")
    if name == ''
        return
    endif
    " Enter visual mode (not sure why this is needed since we're already in
    " visual mode anyway)
    normal! gv

    " Replace selected text with the variable name
    exec "normal c" . name
    " Define the variable on the line above
    exec "normal! O" . name . " = "
    " Paste the original selected text to be the variable value
    normal! $p
endfunction
vnoremap <leader>rv :call ExtractVariable()<cr>

" Function: InlineVariable {{{1
" ------------------------
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" INLINE VARIABLE (SKETCHY)
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! InlineVariable()
    " Copy the variable under the cursor into the 'a' register
    :let l:tmp_a = @a
    :normal "ayiw
    " Delete variable and equals sign
    :normal 2daW
    " Delete the expression into the 'b' register
    :let l:tmp_b = @b
    :normal "bd$
    " Delete the remnants of the line
    :normal dd
    " Go to the end of the previous line so we can start our search for the
    " usage of the variable to replace. Doing '0' instead of 'k$' doesn't
    " work; I'm not sure why.
    normal k$
    " Find the next occurence of the variable
    exec '/\<' . @a . '\>'
    " Replace that occurence with the text we yanked
    exec ':.s/\<' . @a . '\>/' . @b
    :let @a = l:tmp_a
    :let @b = l:tmp_b
endfunction
nnoremap <leader>ri :call InlineVariable()<cr>
nnoremap <leader>Q :!TZ=America/New_York yarn run mocha --opts ./app/javascript/test/mocha.opts %<cr>

" Command: Gshow - populate quickfix list with files from a commit {{{1
" ------------------------
command -nargs=? -bar Gshow call setqflist(map(systemlist("git show --pretty='' --name-only <args>"), '{"filename": v:val, "lnum": 1}'))
" Command: OpenChangedFiles - Open a split for each dirty file in git {{{1
" ------------------------
function! OpenChangedFiles()
  only " Close all windows, unless they're modified
  let status = system('git status -s | grep "^ \?\(M\|A\|UU\)" | sed "s/^.\{3\}//"')
  let filenames = split(status, "\n")
  exec "edit " . filenames[0]
  for filename in filenames[1:]
    exec "sp " . filename
  endfor
endfunction
command! OpenChangedFiles :call OpenChangedFiles()

" Command: InsertTime - Insert the current time {{{1
" ------------------------
command! InsertTime :normal a<c-r>=strftime('%F %H:%M:%S.0 %z')<cr>
command! ConvertTime :normal vi'yci'<c-r>=strftime('%s', <c-r>p)

set makeprg=ant\ \-f\ ~/paths.xml\ test
set errorformat=\ %#[%.%#]\ %#%f:%l:%v:%*\\d:%*\\d:\ %t%[%^:]%#:%m,
    \%A\ %#[%.%#]\ %f:%l:\ %m,%-Z\ %[#[%.%#]\ %p^,%C\ %#[%.%#]\ %#%m
" Command: Incr - Increment a column of like numbers {{{1
" DESCRIPTION:   Given a column of the same number increment each row based on
"                the original number.
" EXAMPLE USAGE: Assuming we have the following column of numbers.
"                1
"                1
"                1
"                1
"                Visually select the numbers and then press <C-n> and the
"                numbers will be incremented to the following
"                1
"                2
"                3
"                4
"===============================================================================
function! Incr()
    let a = line('.') - line("'<")
    let c = virtcol("'<")
    if a > 0
        execute 'normal! '.c.'|'.a."\<C-a>"
    endif
    normal `<
endfunction

"===============================================================================
" Function Keymappings
"===============================================================================
vnoremap <C-n> :call Incr()<CR>

"let g:fold_rspec_foldenable = 0      " disables folding (toggle with `zi`)
"let g:fold_rspec_foldlevel = 2       " sets initial open/closed state of all folds (open unless nested more than two levels deep)
"let g:fold_rspec_foldcolumn = 4      " shows a 4-character column on the lefthand side of the window displaying the document's fold structure
"let g:fold_rspec_foldclose = 'all'   " closes folds automatically when the cursor is moved out of them (only applies to folds deeper than 'foldlevel')
"let g:fold_rspec_foldminlines = 3    " disables closing of folds containing two lines or fewer
" vim:fdm=marker fen ts=2 sts=2 sw=2 et 
hi Special guifg=#2a71dc ctermfg=32
